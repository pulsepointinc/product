
<!DOCTYPE html>
<html>
<head>
    <title>Mermaid Diagram Exporter</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px;
            background: white;
        }
        #diagram { 
            border: 1px solid #ccc; 
            padding: 20px; 
            margin: 20px 0;
            background: white;
            min-height: 200px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        button:disabled { 
            background: #ccc; 
            cursor: not-allowed; 
        }
        #mermaidCode {
            width: 100%;
            height: 200px;
            font-family: monospace;
            margin: 10px 0;
            border: 1px solid #ccc;
            padding: 10px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .loading { background: #cce5ff; border: 1px solid #0066cc; }
        .error { background: #ffe6e6; border: 1px solid #cc0000; }
        .success { background: #e6ffe6; border: 1px solid #00cc00; }
    </style>
</head>
<body>
    <h1>Mermaid Diagram Exporter</h1>
    
    <div id="status" class="status loading">Loading Mermaid library...</div>
    
    <textarea id="mermaidCode" placeholder="Paste your Mermaid diagram code here...">
flowchart TD
    Start([Impression Request<br/>MpcBidRequest]) --> Throttle{Throttle Check<br/>obtainPermission?}
    
    Throttle -->|‚ùå Throttled| ThrottlePassback[üö´ THROTTLED PASSBACK<br/>- Log throttled event<br/>- Return WinnerMpcPassback<br/>- Set throttled=true]
    
    Throttle -->|‚úÖ Allowed| GetMPCs[Get Active MPCs<br/>mpcRepository.getActiveMpcs]
    
    GetMPCs --> FilterMPCs[Apply Composite MPC Filters<br/>CompositeMpcFilter.filter]
    
    FilterMPCs --> FilterDetails{MPC Filtering<br/>Factors}
    FilterDetails --> |Filters Applied| FilterList[
        üîç FILTERING FACTORS:<br/>
        ‚Ä¢ Publisher Restrictions<br/>
        ‚Ä¢ Impression Source Rules<br/>
        ‚Ä¢ Geographic Targeting<br/>
        ‚Ä¢ Expression-based Rules<br/>
        ‚Ä¢ RTB Block Filters<br/>
        ‚Ä¢ MPC Throttle Limits<br/>
        ‚Ä¢ Brokering Tag Filters<br/>
        ‚Ä¢ Creative Preview Filters
    ]
    
    FilterList --> CheckFiltered{Any MPCs<br/>Pass Filters?}
    CheckFiltered -->|‚ùå No MPCs| NoMPCPassback[üö´ NO MPC PASSBACK<br/>- No eligible partners<br/>- Return passback]
    
    CheckFiltered -->|‚úÖ MPCs Available| InitFloors[Initialize Floor Prices<br/>tfRequestService.initializeFloorPrices]
    
    InitFloors --> FloorFactors[
        üí∞ FLOOR PRICE FACTORS:<br/>
        ‚Ä¢ Publisher Ask Price<br/>
        ‚Ä¢ Performance-based Pricing<br/>
        ‚Ä¢ SSP Bid Floor<br/>
        ‚Ä¢ Header Bidder Floors<br/>
        ‚Ä¢ Deal-specific Floors<br/>
        ‚Ä¢ Historical Performance
    ]
    
    FloorFactors --> CollectBids[Collect Bids from MPCs<br/>mpcBidCollectionService.collectBids]
    
    CollectBids --> BidCollection[
        üì° BID COLLECTION:<br/>
        ‚Ä¢ Parallel requests to MPCs<br/>
        ‚Ä¢ Timeout management<br/>
        ‚Ä¢ Response aggregation<br/>
        ‚Ä¢ Failure handling<br/>
        ‚Ä¢ RTB log collection
    ]
    
    BidCollection --> CheckBids{Any Valid<br/>Bids Received?}
    CheckBids -->|‚ùå No Bids| NoBidsPassback[üö´ NO BIDS PASSBACK<br/>- All MPCs failed/timeout<br/>- Return passback with reason]
    
    CheckBids -->|‚úÖ Bids Available| WinnerSelection[Winner Selection Engine<br/>EDWinnerSelectionEngine.pickWinner]
    
    WinnerSelection --> AuctionTiers{Auction Tier Selection}
    
    AuctionTiers --> Tier1[
        ü•á TIER 1: PREFERRED DEALS<br/>
        ‚Ä¢ Highest Priority<br/>
        ‚Ä¢ Guaranteed delivery contracts<br/>
        ‚Ä¢ Premium buyer agreements<br/>
        ‚Ä¢ Deal ID validation<br/>
        ‚Ä¢ Margin verification
    ]
    
    AuctionTiers --> Tier2[
        ü•à TIER 2: PREMIUM MARKETPLACE<br/>
        ‚Ä¢ Premium inventory<br/>
        ‚Ä¢ Enhanced targeting<br/>
        ‚Ä¢ Higher margin requirements<br/>
        ‚Ä¢ Advanced bid strategies
    ]
    
    AuctionTiers --> Tier3[
        ü•â TIER 3: OPEN AUCTIONS<br/>
        ‚Ä¢ Standard programmatic<br/>
        ‚Ä¢ Multiple auction types<br/>
        ‚Ä¢ Fallback mechanism
    ]
    
    Tier1 --> CheckPreferred{Preferred Deal<br/>Bids Available?}
    CheckPreferred -->|‚úÖ Yes| PreferredAuction[Preferred Deal Auction<br/>- Validate deal terms<br/>- Check margins<br/>- Guarantee delivery]
    CheckPreferred -->|‚ùå No| Tier2
    
    Tier2 --> CheckPremium{Premium Marketplace<br/>Criteria Met?}
    CheckPremium -->|‚úÖ Yes| PremiumAuction[Premium Marketplace Auction<br/>- Enhanced targeting<br/>- Premium margins<br/>- Advanced strategies]
    CheckPremium -->|‚ùå No| Tier3
    
    Tier3 --> AuctionTypes{Select Auction Type}
    
    AuctionTypes --> TwoPhase[
        üîÑ TWO-PHASE AUCTION<br/>
        For: BidType.EXTERNAL_TWO_PHASE<br/>
        ‚Ä¢ Calculate external bid price<br/>
        ‚Ä¢ Apply margins & ceiling<br/>
        ‚Ä¢ Floor price validation
    ]
    
    AuctionTypes --> TopMPC[
        üéØ TOP MPC AUCTION<br/>
        For: Standard RTB bids<br/>
        ‚Ä¢ MPC is top bidder<br/>
        ‚Ä¢ Apply MPC margins<br/>
        ‚Ä¢ Upstream bid calculation
    ]
    
    AuctionTypes --> RulesBased[
        üß† RULES-BASED AUCTION<br/>
        For: Complex optimization<br/>
        ‚Ä¢ ML/rules engine<br/>
        ‚Ä¢ Historical performance<br/>
        ‚Ä¢ Contextual signals
    ]
    
    PreferredAuction --> MarginCheck
    PremiumAuction --> MarginCheck
    TwoPhase --> MarginCheck
    TopMPC --> MarginCheck
    RulesBased --> MarginCheck
    
    MarginCheck{Margin & Floor<br/>Validation}
    
    MarginCheck --> MarginFactors[
        üìä MARGIN CALCULATION FACTORS:<br/>
        ‚Ä¢ Buyer fee structure<br/>
        ‚Ä¢ Publisher revenue share<br/>
        ‚Ä¢ Performance history<br/>
        ‚Ä¢ Deal-specific margins<br/>
        ‚Ä¢ Market conditions<br/>
        ‚Ä¢ Auction cost basis
    ]
    
    MarginFactors --> FloorCheck{Final Bid ‚â•<br/>Floor Price?}
    
    FloorCheck -->|‚ùå Below Floor| BelowFloorPassback[üö´ BELOW FLOOR PASSBACK<br/>- Bid doesn't meet minimum<br/>- Margin requirements failed<br/>- Return passback]
    
    FloorCheck -->|‚úÖ Above Floor| DealValidation{Deal Constraints<br/>Satisfied?}
    
    DealValidation -->|‚ùå Failed| DealFailPassback[üö´ DEAL VALIDATION FAILED<br/>- Deal terms not met<br/>- Contract violations<br/>- Return passback]
    
    DealValidation -->|‚úÖ Passed| CreativeValidation{Creative &<br/>Technical Validation}
    
    CreativeValidation -->|‚ùå Failed| TechnicalPassback[üö´ TECHNICAL FAILURE<br/>- Creative issues<br/>- Technical validation failed<br/>- Return passback]
    
    CreativeValidation -->|‚úÖ Passed| Winner[üéâ WINNING IMPRESSION<br/>WinnerMpcStandard]
    
    Winner --> MacroReplace[Macro Replacement<br/>edMacroReplacer.process]
    
    MacroReplace --> MacroDetails[
        üîß MACRO PROCESSING:<br/>
        ‚Ä¢ Price placeholders<br/>
        ‚Ä¢ Targeting information<br/>
        ‚Ä¢ Tracking pixels<br/>
        ‚Ä¢ Security encoding<br/>
        ‚Ä¢ URL parameters
    ]
    
    MacroDetails --> FinalResponse[üì§ SERVE PAID IMPRESSION<br/>ExchangeResponse with:<br/>‚Ä¢ Final bid price<br/>‚Ä¢ Creative content<br/>‚Ä¢ Billing details<br/>‚Ä¢ Tracking information]
    
    Winner --> Logging[Wide Log Event<br/>wideLogManager.logEvent]
    ThrottlePassback --> Logging
    NoMPCPassback --> Logging
    NoBidsPassback --> Logging
    BelowFloorPassback --> Logging
    DealFailPassback --> Logging
    TechnicalPassback --> Logging
    
    Logging --> LogDetails[
        üìù LOGGING & ANALYTICS:<br/>
        ‚Ä¢ Auction decisions<br/>
        ‚Ä¢ Performance metrics<br/>
        ‚Ä¢ Revenue tracking<br/>
        ‚Ä¢ Bid analysis<br/>
        ‚Ä¢ Error reporting
    ]
    
    FinalResponse --> End([Response Delivered])
    LogDetails --> End
    
    %% Styling
    classDef successClass fill:#d4edda,stroke:#155724,stroke-width:2px
    classDef failureClass fill:#f8d7da,stroke:#721c24,stroke-width:2px
    classDef processClass fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef decisionClass fill:#fff3cd,stroke:#856404,stroke-width:2px
    classDef factorClass fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    
    class FinalResponse,Winner successClass
    class ThrottlePassback,NoMPCPassback,NoBidsPassback,BelowFloorPassback,DealFailPassback,TechnicalPassback failureClass
    class GetMPCs,FilterMPCs,InitFloors,CollectBids,WinnerSelection,MacroReplace processClass
    class Throttle,CheckFiltered,CheckBids,FloorCheck,DealValidation,CreativeValidation decisionClass
    class FilterList,FloorFactors,BidCollection,MarginFactors,MacroDetails,LogDetails factorClass
    </textarea>
    
    <button id="renderBtn" onclick="renderDiagram()" disabled>üé® Render Diagram</button>
    <button id="svgBtn" onclick="downloadSVG()" disabled>‚¨áÔ∏è Download SVG</button>
    <button id="pngBtn" onclick="downloadPNG()" disabled>‚¨áÔ∏è Download PNG</button>
    
    <div id="diagram"></div>

    <!-- Multiple CDN fallbacks -->
    <script>
        let mermaidLoaded = false;
        let currentMermaid = null;

        function updateStatus(message, type = 'loading') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function enableButtons() {
            document.getElementById('renderBtn').disabled = false;
            document.getElementById('svgBtn').disabled = false;
            document.getElementById('pngBtn').disabled = false;
        }

        function loadMermaid() {
            // Try multiple CDN sources
            const cdns = [
                'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js',
                'https://unpkg.com/mermaid@10/dist/mermaid.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js'
            ];

            function tryNextCDN(index = 0) {
                if (index >= cdns.length) {
                    updateStatus('‚ùå Failed to load Mermaid from all CDNs. Please check your internet connection.', 'error');
                    return;
                }

                const script = document.createElement('script');
                script.src = cdns[index];
                
                script.onload = function() {
                    if (typeof mermaid !== 'undefined') {
                        currentMermaid = mermaid;
                        mermaidLoaded = true;
                        
                        // Initialize mermaid
                        currentMermaid.initialize({ 
                            startOnLoad: false,
                            theme: 'default',
                            securityLevel: 'loose',
                            themeVariables: {
                                primaryColor: '#ff6b6b',
                                primaryTextColor: '#fff',
                                primaryBorderColor: '#ff4757',
                                lineColor: '#3742fa',
                                sectionBkgColor: '#7bed9f',
                                altSectionBkgColor: '#70a1ff',
                                gridColor: '#2f3542',
                                secondaryColor: '#2ed573',
                                tertiaryColor: '#eccc68'
                            }
                        });
                        
                        updateStatus('‚úÖ Mermaid loaded successfully! You can now render and download diagrams.', 'success');
                        enableButtons();
                        
                        // Auto-render
                        setTimeout(renderDiagram, 500);
                    } else {
                        tryNextCDN(index + 1);
                    }
                };
                
                script.onerror = function() {
                    updateStatus(`‚ö†Ô∏è CDN ${index + 1} failed, trying next...`, 'loading');
                    tryNextCDN(index + 1);
                };
                
                document.head.appendChild(script);
            }

            tryNextCDN();
        }

        function renderDiagram() {
            if (!mermaidLoaded || !currentMermaid) {
                updateStatus('‚ùå Mermaid not loaded yet. Please wait or refresh the page.', 'error');
                return;
            }

            const code = document.getElementById('mermaidCode').value.trim();
            const diagramDiv = document.getElementById('diagram');
            
            if (!code) {
                updateStatus('‚ùå Please enter some Mermaid code first.', 'error');
                return;
            }
            
            try {
                updateStatus('üé® Rendering diagram...', 'loading');
                diagramDiv.innerHTML = '<div style="text-align: center; padding: 20px;">Rendering...</div>';
                
                // Generate unique ID
                const diagramId = 'diagram-' + Date.now();
                
                currentMermaid.render(diagramId, code).then(function(result) {
                    diagramDiv.innerHTML = result.svg;
                    updateStatus('‚úÖ Diagram rendered successfully!', 'success');
                }).catch(function(error) {
                    console.error('Mermaid render error:', error);
                    diagramDiv.innerHTML = '<p style="color: red; padding: 20px;">Error rendering diagram: ' + error.message + '</p>';
                    updateStatus('‚ùå Error rendering diagram: ' + error.message, 'error');
                });
                
            } catch (error) {
                console.error('Render error:', error);
                diagramDiv.innerHTML = '<p style="color: red; padding: 20px;">Error rendering diagram: ' + error.message + '</p>';
                updateStatus('‚ùå Error rendering diagram: ' + error.message, 'error');
            }
        }

        function downloadSVG() {
            const svgElement = document.querySelector('#diagram svg');
            if (!svgElement) {
                alert('Please render the diagram first!');
                return;
            }
            
            // Clone and clean up the SVG
            const svgClone = svgElement.cloneNode(true);
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            const svgData = new XMLSerializer().serializeToString(svgClone);
            const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
            
            const downloadLink = document.createElement('a');
            downloadLink.href = URL.createObjectURL(svgBlob);
            downloadLink.download = 'impression-serving-flow.svg';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            updateStatus('‚¨áÔ∏è SVG downloaded successfully!', 'success');
        }

        function downloadPNG() {
            const svgElement = document.querySelector('#diagram svg');
            if (!svgElement) {
                alert('Please render the diagram first!');
                return;
            }
            
            updateStatus('üì∑ Converting to PNG...', 'loading');
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            // Get SVG dimensions
            const svgRect = svgElement.getBoundingClientRect();
            const svgData = new XMLSerializer().serializeToString(svgElement);
            
            // Create blob URL
            const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(svgBlob);
            
            img.onload = function() {
                // Set high resolution
                const scale = 2;
                canvas.width = img.naturalWidth * scale || svgRect.width * scale;
                canvas.height = img.naturalHeight * scale || svgRect.height * scale;
                
                ctx.scale(scale, scale);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                
                canvas.toBlob(function(blob) {
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(blob);
                    downloadLink.download = 'impression-serving-flow.png';
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    updateStatus('‚¨áÔ∏è PNG downloaded successfully!', 'success');
                }, 'image/png');
                
                URL.revokeObjectURL(url);
            };
            
            img.onerror = function() {
                updateStatus('‚ùå Error converting to PNG. Try SVG download instead.', 'error');
                URL.revokeObjectURL(url);
            };
            
            img.src = url;
        }

        // Start loading when page loads
        window.onload = function() {
            loadMermaid();
        };
    </script>
</body>
</html>
